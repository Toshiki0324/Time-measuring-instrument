[{"id":"2f489a1c.4a05b6","type":"tab","label":"Flow 1","disabled":false,"info":""},{"id":"b6b3f9c0.9aefa8","type":"mqtt-broker","name":"","broker":"192.168.10.16","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"39af89f4.368cc6","type":"ui_tab","name":"Time measuring instrument","icon":"dashboard","order":18,"disabled":false,"hidden":false},{"id":"3b6fc506.b120ca","type":"ui_group","name":"Default Group","tab":"39af89f4.368cc6","order":1,"disp":false,"width":"16","collapse":false},{"id":"4bce468f.128238","type":"ui_base","theme":{"name":"theme-dark","lightTheme":{"default":"#0094CE","baseColor":"#0094CE","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":true,"reset":false},"darkTheme":{"default":"#097479","baseColor":"#097479","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif","edited":true,"reset":false},"customTheme":{"name":"Untitled Theme 1","default":"#4B7930","baseColor":"#4B7930","baseFont":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"},"themeState":{"base-color":{"default":"#097479","value":"#097479","edited":false},"page-titlebar-backgroundColor":{"value":"#097479","edited":false},"page-backgroundColor":{"value":"#111111","edited":false},"page-sidebar-backgroundColor":{"value":"#333333","edited":false},"group-textColor":{"value":"#0eb8c0","edited":false},"group-borderColor":{"value":"#555555","edited":false},"group-backgroundColor":{"value":"#333333","edited":false},"widget-textColor":{"value":"#eeeeee","edited":false},"widget-backgroundColor":{"value":"#097479","edited":false},"widget-borderColor":{"value":"#333333","edited":false},"base-font":{"value":"-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif"}},"angularTheme":{"primary":"indigo","accents":"blue","warn":"red","background":"grey"}},"site":{"name":"Node-RED Dashboard","hideToolbar":"false","allowSwipe":"false","lockMenu":"false","allowTempTheme":"true","dateFormat":"DD/MM/YYYY","sizes":{"sx":48,"sy":48,"gx":6,"gy":6,"cx":6,"cy":6,"px":0,"py":0}}},{"id":"b02bd436.da2208","type":"mqtt-broker","name":"my-mqtt-broker","broker":"localhost","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"c6807e0a.47ab","type":"ui_group","name":"Object Detection Demo","tab":"295b6d28.1c5a92","order":1,"disp":true,"width":"6","collapse":false},{"id":"295b6d28.1c5a92","type":"ui_tab","name":"Home","icon":"dashboard","disabled":false,"hidden":false},{"id":"9205c5fc.c7cd98","type":"mqtt-broker","name":"","broker":"192.168.2.38","port":"1883","clientid":"","usetls":false,"compatmode":false,"keepalive":"60","cleansession":true,"birthTopic":"","birthQos":"0","birthPayload":"","closeTopic":"","closeQos":"0","closePayload":"","willTopic":"","willQos":"0","willPayload":""},{"id":"8af375da.3cbb98","type":"mqtt in","z":"2f489a1c.4a05b6","name":"","topic":"test","qos":"2","datatype":"auto","broker":"b6b3f9c0.9aefa8","x":50,"y":200,"wires":[["6a9139e6.e34528"]]},{"id":"2fe5041f.9ea24c","type":"debug","z":"2f489a1c.4a05b6","name":"","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"false","statusVal":"","statusType":"auto","x":310,"y":200,"wires":[]},{"id":"9d4bd2dd.2039","type":"inject","z":"2f489a1c.4a05b6","name":"Update Chart","repeat":"10","crontab":"","once":false,"topic":"","payload":"","payloadType":"date","x":380,"y":580,"wires":[["8da01ad2.268c08"]]},{"id":"190d9e6d.358372","type":"debug","z":"2f489a1c.4a05b6","name":"debug msg object","active":false,"console":"false","complete":"true","x":850,"y":460,"wires":[]},{"id":"8da01ad2.268c08","type":"ui_template","z":"2f489a1c.4a05b6","group":"3b6fc506.b120ca","name":"chartjs timeline","order":0,"width":"13","height":"7","format":"<script>\nvar max_duration = .01; // number of hours of history to show\n\nvar labels = [];\nvar datasets = [];\nvar colorArray = ['#FF6633','#4D4D4D','#5DA5DA','#FAA43A','#60BD68','#F17CB0','#B2912F','#B276B2','#DECF3F','#F15854'];\n\n\nvar ctx = document.getElementById(\"canvas\").getContext(\"2d\");\n\n// window.timeline = new Chart(ctx, {\nvar chart = new Chart(ctx, {\n    type: 'timeLine',\n    options: {\n        responsive: true,\n        colorFunction: function(data){\n            // data is the dataset event point.\n            // The first and second entries are the start/stop date\n            //The third entry specifies the color to use\n            return (typeof data[2] === 'undefined' ? 'black' : data[2]);\n        }\n    },\n    data: {\n        labels: labels,\n        datasets: datasets\n    }\n    \n    //   data: {\n    //     labels: [\"Joe\", \"Bob\", \"Jim\", \"Alice\"],\n    //     datasets: [{\n    //         data: [\n    //             [new Date('2018-04-11'), new Date('2018-04-12')],\n    //             [new Date('2018-04-14'), new Date('2018-04-18')],\n    //             [new Date('2018-04-25'), new Date('2018-04-27')]\n    //         ]\n    //     }, {\n    //         data: [\n    //             [getDate(1), getDate(3)],\n    //             [getDate(4), getDate(6)],\n    //             [getDate(7), getDate(9)]\n    //         ]\n    //     }, {\n    //         data: [\n    //             [getDate(3), getDate(5)],\n    //             [getDate(6), getDate(9)]\n    //         ]\n    //     }, {\n    //         data: [\n    //             [getDate(3), getDate(5)],\n    //             [getDate(6), getDate(20)]\n    //         ]\n    //     }]\n    // }\n});\n    \n(function(scope){\n    scope.$watch('msg', function(msg) {\n        if(typeof(msg) !== \"object\") return;\n        \n        if(typeof(msg.cache) === \"object\"){\n            console.log(\"Read cache\");\n            \n            // It blows up here!\n            labels = [];\n            datasets = [];\n            \n            // for(var i in msg.cache.labels){\n                // scope.labels[i] = msg.cache.labels[i];\n            // }\n            // scope.labels = msg.cache.labels;\n            \n            // console.log(scope.labels);\n            // console.log(msg.cache.datasets);\n            \n            \n            // scope.labels = [\"a\"];\n            // scope.datasets = [{data: [\n            //         [new Date('2018-04-11'), new Date('2018-04-12')],\n            //         [new Date('2018-04-14'), new Date('2018-04-18')],\n            //         [new Date('2018-04-25'), new Date('2018-04-27')]\n            //     ]}];\n            // scope.datasets = msg.cache.datasets;\n            // return null;\n        }\n\n        if(typeof(msg.topic) === \"string\" && typeof(msg.payload) === \"boolean\"){\n            /* Begin history tracking */\n            // Doesn't exist so init the object\n            if(labels.indexOf(msg.topic) == -1){\n                labels.push(msg.topic);\n                \n                datasets.push({\n                    label: msg.topic,\n                    current: false,\n                    timestamp: new Date(),\n                    data: []\n                });\n            }\n            \n            var thisIndex = labels.indexOf(msg.topic);\n            \n            // The state has changed\n            if(msg.payload != datasets[thisIndex].current){\n                datasets[thisIndex].current = msg.payload;\n                datasets[thisIndex].timestamp = new Date();\n                \n                // Only add a new event if the state switched from false to true\n                if(msg.payload === true){\n                    // add a new start/stop event to the topics history\n                    var event = [new Date(), new Date(), colorArray[thisIndex]];\n                    datasets[thisIndex].data.push(event);\n                }\n            }\n        }\n        \n        \n        angular.forEach(datasets, function(topic){\n            if(topic.current === true && topic.data.length){\n                // Update the event stop time to the current time\n                topic.data[topic.data.length - 1][1] = new Date();\n            }\n            \n\n            angular.forEach(topic.data, function(event, index, object){\n                // cleanup old history (anything with an ending time more than max_duration hours old)\n                if(new Date() - event[1] > max_duration * 3600000){\n                    // Delete the event\n                    object.splice(index,1);\n                }\n            });\n        });\n        \n        /* END History tracking */\n        \n        // Force the timeline to redraw by adding an event to the end of the first bar\n        // if(scope.datasets.length){\n        //     scope.datasets[0].data[0].push([new Date(), new Date()]);\n        // }\n\nconsole.log(chart.config.data.labels);\n\n        //redraw\n        chart.update();\n        \n        // if(scope.datasets.length){\n        //     scope.datasets[0].data[0].pop();\n        // }\n        \n        // This triggers a never ending loop for some reason\n        var metas = [];\n        for(var i in datasets){\n            metas[i] = datasets[i]._meta;\n            delete datasets[i]._meta;\n        }\n        \n        // Attempting to make chart persistence between deploys\n        scope.send({cache: chart.config.data});\n        // scope.send({payload: [\"one\"]});\n        \n        // put the meta property back in\n        for(var i in datasets){\n            datasets[i]._meta = metas[i];\n        }\n\n\n    });\n})(scope);\n\n\n</script>\n\n<div style=\"width: 100%;\">\n    <canvas id=\"canvas\"></canvas>\n</div>","storeOutMessages":false,"fwdInMessages":false,"resendOnRefresh":false,"templateScope":"local","x":620,"y":460,"wires":[["190d9e6d.358372"]]},{"id":"3118460e.fa9faa","type":"ui_template","z":"2f489a1c.4a05b6","group":"3b6fc506.b120ca","name":"ChartJS Timeline Library","order":0,"width":0,"height":0,"format":"<script>\nconst helpers = Chart.helpers;\nconst isArray = helpers.isArray;\n\nvar time = {\n\t\tunits: [{\n\t\t\tname: 'millisecond',\n\t\t\tsteps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n\t\t}, {\n\t\t\tname: 'second',\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t}, {\n\t\t\tname: 'minute',\n\t\t\tsteps: [1, 2, 5, 10, 30]\n\t\t}, {\n\t\t\tname: 'hour',\n\t\t\tsteps: [1, 2, 3, 6, 12]\n\t\t}, {\n\t\t\tname: 'day',\n\t\t\tsteps: [1, 2, 3, 5]\n\t\t}, {\n\t\t\tname: 'week',\n\t\t\tmaxStep: 4\n\t\t}, {\n\t\t\tname: 'month',\n\t\t\tmaxStep: 3\n\t\t}, {\n\t\t\tname: 'quarter',\n\t\t\tmaxStep: 4\n\t\t}, {\n\t\t\tname: 'year',\n\t\t\tmaxStep: false\n\t\t}]\n};\n\nvar myConfig = {\n    myTime : {\n        redoLabels: false\n    },\n    position: 'bottom',\n\n    time: {\n        parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment\n        format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/\n        unit: false, // false == automatic or override with week, month, year, etc.\n        round: false, // none, or override with week, month, year, etc.\n        displayFormat: false, // DEPRECATED\n        isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/\n        minUnit: 'millisecond',\n\n        // defaults to unit's corresponding unitFormat below or override using pattern string from http://momentjs.com/docs/#/displaying/format/\n        displayFormats: {\n            millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,\n            second: 'h:mm:ss a', // 11:20:01 AM\n            minute: 'h:mm:ss a', // 11:20:01 AM\n            quarter: '[Q]Q - YYYY', // Q3\n            year: 'YYYY', // 2015        \n            hour: 'MMM D, hA', // Sept 4, 5PM\n            day: 'll', // Sep 4 2015\n            week: 'll', // Week 46, or maybe \"[W]WW - YYYY\" ?\n            month: 'MMM YYYY', // Sept 2015\n            }\n    },\n    ticks: {\n        autoSkip: false\n    }\n};\n\n\nvar myTimeScale = Chart.scaleService.getScaleConstructor('time').extend({\n\n    determineDataLimits: function() {\n        var me = this;\n        me.labelMoments = [];\n\n        // We parse all date labels here, for each entry we parse its initial and end date\n        var scaleLabelMoments = [];\n        if (me.chart.data.datasets && me.chart.data.datasets.length > 0) {\n            helpers.each(me.chart.data.datasets, function(datasets) {\n                var data = datasets.data;\n                var length = data.length;\n                for (var i = 0; i < length; i++) {\n                    // We consider 0 to have initial date\n                    var initialLabelMoment = me.parseTime(data[i][0]);\n                    // we consider 1 to have end date\n                    // TODO maybe add a check to see which one is bigger, but right now i don't know the\n                    // TODO implications off that check\n                    var finalLabelMoment = me.parseTime(data[i][1]);\n                    if (initialLabelMoment.isValid()) {\n                        if (me.options.time.round) {\n                            initialLabelMoment.startOf(me.options.time.round);\n                        }\n                        scaleLabelMoments.push(initialLabelMoment);\n                    }\n                    if (finalLabelMoment.isValid()) {\n                        if (me.options.time.round) {\n                            finalLabelMoment.startOf(me.options.time.round);\n                        }\n                        scaleLabelMoments.push(finalLabelMoment);\n                    }\n                }\n            }, me);\n\n            me.firstTick = moment.min.call(me, scaleLabelMoments);\n            me.lastTick = moment.max.call(me, scaleLabelMoments);\n        } else {\n            me.firstTick = null;\n            me.lastTick = null;\n        }\n\n        // In this case label moments are the same as scale moments because this chart only supports\n        // dates as data and not labels like normal time scale. We are doing this to keep\n        // coordination between parent(TimeScale) calls\n        me.labelMoments.push(scaleLabelMoments);\n\n        // Set these after we've done all the data\n        if (me.options.time.min) {\n            me.firstTick = me.parseTime(me.options.time.min);\n        }\n\n        if (me.options.time.max) {\n            me.lastTick = me.parseTime(me.options.time.max);\n        }\n\n        // We will modify these, so clone for later\n        me.firstTick = (me.firstTick || moment()).clone();\n        me.lastTick = (me.lastTick || moment()).clone();\n    },\n    buildLabelDiffs: function() {\n        var me = this;\n        me.labelDiffs = [];\n        var scaleLabelDiffs = [];\n        // Parse common labels once\n        if (me.chart.data.datasets && me.chart.data.datasets.length > 0) {\n            helpers.each(me.chart.data.datasets, function(datasets, datasetIndex) {\n                var data = datasets.data;\n                var length = data.length;\n                for (var i = 0; i < length; i++) {\n                    // We consider 0 to have initial date\n                    var initialLabelMoment = me.parseTime(data[i][0]);\n                    // we consider 1 to have end date\n                    // TODO maybe add a check to see which one is bigger, but right now i don't know the\n                    // TODO implications off that check\n                    var finalLabelMoment = me.parseTime(data[i][1]);\n                    var diff;\n                    if (initialLabelMoment.isValid()) {\n                        if (me.options.time.round) {\n                            diff = initialLabelMoment.diff(me.firstTick, me.tickUnit, false);\n                        }\n                        else {\n                            if (me.isInTicks(initialLabelMoment, me.tickUnit))\n                            // No floor needed since we are one of the ticks\n                                diff = initialLabelMoment.diff(me.firstTick, me.tickUnit, false);\n                            else\n                                diff = initialLabelMoment.diff(me.firstTick, me.tickUnit, true);\n                        }\n                        scaleLabelDiffs.push(diff);\n                    }\n                    if (finalLabelMoment.isValid()) {\n                        if (me.options.time.round) {\n                            // Moment doesn't round on diff anymore\n                            diff = finalLabelMoment.diff(me.firstTick, me.tickUnit, false);\n                        }\n                        else\n                        {\n                            if (me.isInTicks(finalLabelMoment, me.tickUnit))\n                            // No floor needed since we are one of the ticks\n                                diff = finalLabelMoment.diff(me.firstTick, me.tickUnit, false);\n                            else\n                                diff = finalLabelMoment.diff(me.firstTick, me.tickUnit, true);\n                        }\n                        scaleLabelDiffs.push(diff);\n                    }\n                }\n                me.labelDiffs[datasetIndex] = scaleLabelDiffs;\n                scaleLabelDiffs = [];\n            }, me);\n        }\n\n\n    },\n\n    // This function is different from parent because the second argument of the index inside the array of dates\n    // e.g [initialDate, endDate]. Since we built the diffs in date order, which means that every 2 entries in\n    // me.labelDiffs represent one set of date with initial and end dates by order.\n    getLabelDiff: function (datasetIndex, dateIndex) {\n        var me = this;\n        if (datasetIndex === null || dateIndex === null)\n            return null;\n\n        if (me.labelDiffs === undefined)\n            me.buildLabelDiffs();\n\n        if (me.labelDiffs[datasetIndex] != undefined)\n            return me.labelDiffs[datasetIndex][dateIndex];\n\n        return null;\n    },\n\n    getPixelForValue: function(value, index, datasetIndex) {\n        var me = this;\n        var offset = null;\n        if (index !== undefined && datasetIndex !== undefined) {\n            offset = me.getLabelDiff(datasetIndex, index);\n        }\n\n        if (offset === null) {\n            if (!value || !value.isValid) {\n                // not already a moment object\n                value = me.parseTime(me.getRightValue(value));\n            }\n            if (value && value.isValid && value.isValid()) {\n                offset = value.diff(me.firstTick, me.tickUnit, false);\n            }\n        }\n\n        if (offset !== null) {\n            var decimal = offset !== 0 ? offset / me.scaleSizeInUnits : offset;\n\n            if (me.isHorizontal()) {\n                var valueOffset = (me.width * decimal);\n                return me.left + Math.round(valueOffset);\n            }\n\n            var heightOffset = (me.height * decimal);\n            return me.top + Math.round(heightOffset);\n        }\n    },\n\n    // Checks if some date object is a tickMoment\n    isInTicks: function (date, unit) {\n        var result = false;\n        var length = this.tickMoments.length;\n        var ticks = this.tickMoments;\n        for(var i = 0; i < length; i++)\n        {\n            var tick = ticks[i];\n            if (date.isSame(tick, unit))\n            {\n                result = true;\n                break;\n            }\n        }\n        return result;\n    }\n});\n\n\nChart.scaleService.registerScaleType('myTime', myTimeScale, myConfig);\n\n\n\nChart.controllers.timeLine = Chart.controllers.bar.extend({\n\n    getBarBounds : function (bar) {\n        var vm =   bar._view;\n        var x1, x2, y1, y2;\n\n        x1 = vm.x;\n        x2 = vm.x + vm.width;\n        y1 = vm.y;\n        y2 = vm.y + vm.height;\n\n        return {\n            left : x1,\n            top: y1,\n            right: x2,\n            bottom: y2\n        };\n\n    },\n\n    update: function(reset) {\n        var me = this;\n        var meta = me.getMeta();\n        helpers.each(meta.data, function(rectangle, index) {\n            me.updateElement(rectangle, index, reset);\n        }, me);\n    },\n\n    updateElement: function(rectangle, index, reset) {\n        var me = this;\n        var meta = me.getMeta();\n        var xScale = me.getScaleForId(meta.xAxisID);\n        var yScale = me.getScaleForId(meta.yAxisID);\n        var dataset = me.getDataset();\n        var data = dataset.data[index];\n        var custom = rectangle.custom || {};\n        var datasetIndex = me.index;\n        var rectangleElementOptions = me.chart.options.elements.rectangle;\n\n        rectangle._xScale = xScale;\n        rectangle._yScale = yScale;\n        rectangle._datasetIndex = me.index;\n        rectangle._index = index;\n\n        var ruler = me.getRuler(index);\n\n        if (index !== 0)\n            index = index * 2;\n\n        var x = xScale.getPixelForValue(data, index , datasetIndex);\n        index++;\n        var end = xScale.getPixelForValue(data, index, datasetIndex);\n\n        var y = yScale.getPixelForValue(data, datasetIndex, datasetIndex);\n        var width = end - x;\n        var height = me.calculateBarHeight(ruler);\n        var color = me.chart.options.colorFunction(data);\n\n        // This one has in account the size of the tick and the height of the bar, so we just\n        // divide both of them by two and subtract the height part and add the tick part\n        // to the real position of the element y. The purpose here is to place the bar\n        // in the middle of the tick.\n        var boxY = y + (ruler.tickHeight / 2) - (height / 2);\n\n        // console.log(me.chart.data.labels[index] + ' box x ' + index + ' : ' + x);\n        // console.log(me.chart.data.labels[index] + ' box y ' + index + ' : ' + boxY);\n        rectangle._model = {\n            x: reset ?  x - width : x,   // Top left of rectangle\n            y: boxY , // Top left of rectangle\n            width: width,\n            height: height,\n            base: x + width,\n            backgroundColor: color,\n            borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleElementOptions.borderSkipped,\n            borderColor: custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor),\n            borderWidth: custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth),\n            // Tooltip\n            label: me.chart.data.labels[index],\n            datasetLabel: dataset.label\n        };\n\n\n\n        rectangle.draw = function() {\n            var ctx = this._chart.ctx;\n            var vm = this._view;\n            ctx.fillStyle = vm.backgroundColor;\n            ctx.lineWidth = vm.borderWidth;\n            helpers.drawRoundedRectangle(ctx, vm.x, vm.y, vm.width, vm.height, 1);\n            ctx.fill();\n        };\n\n        rectangle.inXRange = function (mouseX) {\n            var bounds = me.getBarBounds(this);\n            return mouseX >= bounds.left && mouseX <= bounds.right;\n        };\n        rectangle.tooltipPosition = function () {\n            var vm = this.getCenterPoint();\n            return {\n                x: vm.x ,\n                y: vm.y\n            };\n        };\n\n        rectangle.getCenterPoint = function () {\n            var vm = this._view;\n            var x, y;\n            x = vm.x + (vm.width / 2);\n            y = vm.y + (vm.height / 2);\n\n            return {\n                x : x,\n                y : y\n            };\n        };\n\n        rectangle.inRange = function (mouseX, mouseY) {\n            var inRange = false;\n\n            if(this._view)\n            {\n                var bounds = me.getBarBounds(this);\n                inRange = mouseX >= bounds.left && mouseX <= bounds.right &&\n                    mouseY >= bounds.top && mouseY <= bounds.bottom;\n            }\n            return inRange;\n        };\n\n        rectangle.pivot();\n    },\n\n    // From controller.bar\n    getRuler: function(index) {\n        var me = this;\n        var meta = me.getMeta();\n        var yScale = me.getScaleForId(meta.yAxisID);\n        var datasetCount = me.getBarCount();\n\n        var tickHeight;\n        if (yScale.options.type === 'category') {\n            tickHeight = yScale.getPixelForTick(index + 1) - yScale.getPixelForTick(index);\n        } else {\n            // Average width\n            tickHeight = yScale.width / yScale.ticks.length;\n        }\n        var categoryHeight = tickHeight * yScale.options.categoryPercentage;\n        var categorySpacing = (tickHeight - (tickHeight * yScale.options.categoryPercentage)) / 2;\n        var fullBarHeight = categoryHeight / datasetCount;\n\n        if (yScale.ticks.length !== me.chart.data.labels.length) {\n            var perc = yScale.ticks.length / me.chart.data.labels.length;\n            fullBarHeight = fullBarHeight * perc;\n        }\n\n        var barHeight = fullBarHeight * yScale.options.barPercentage;\n        var barSpacing = fullBarHeight - (fullBarHeight * yScale.options.barPercentage);\n\n        return {\n            datasetCount: datasetCount,\n            tickHeight: tickHeight,\n            categoryHeight: categoryHeight,\n            categorySpacing: categorySpacing,\n            fullBarHeight: fullBarHeight,\n            barHeight: barHeight,\n            barSpacing: barSpacing\n        };\n    },\n\n    // From controller.bar\n    getBarCount: function() {\n        var me = this;\n        var barCount = 0;\n        helpers.each(me.chart.data.datasets, function(dataset, datasetIndex) {\n            var meta = me.chart.getDatasetMeta(datasetIndex);\n            if (meta.bar && me.chart.isDatasetVisible(datasetIndex)) {\n                ++barCount;\n            }\n        }, me);\n        return barCount;\n    },\n\n\n    // draw\n    draw: function (ease) {\n        var easingDecimal = ease || 1;\n        var i, len;\n        var metaData = this.getMeta().data;\n        for (i = 0, len = metaData.length; i < len; i++)\n        {\n            metaData[i].transition(easingDecimal).draw();\n        }\n    },\n\n    // From controller.bar\n    calculateBarHeight: function(ruler) {\n        var me = this;\n        var yScale = me.getScaleForId(me.getMeta().yAxisID);\n        if (yScale.options.barThickness) {\n            return yScale.options.barThickness;\n        }\n        return yScale.options.stacked ? ruler.categoryHeight : ruler.barHeight;\n    },\n\n    removeHoverStyle: function(e) {\n        // TODO\n    },\n\n    setHoverStyle: function(e) {\n        // TODO: Implement this\n    }\n\n});\n\n\nChart.defaults.timeLine = {\n\n    colorFunction: function() {\n        return 'black';\n    },\n\n    layout: {\n        padding: {\n            left: 5,\n            right: 5,\n            top: 0\n        }\n    },\n\n    legend: {\n        display: false\n    },\n\n    scales: {\n        xAxes: [{\n            type: 'myTime',\n            position: 'bottom',\n            gridLines: {\n                display: true,\n                offsetGridLines: true,\n                drawBorder: true,\n                drawTicks: true\n            },\n            ticks: {\n                maxRotation: 0\n            },\n            unit: 'day'\n        }],\n        yAxes: [{\n            type: 'category',\n            position: 'left',\n            barThickness : 20,\n            gridLines: {\n                display: true,\n                offsetGridLines: true,\n                drawBorder: true,\n                drawTicks: true\n            }\n        }]\n    },\n    tooltips: {\n        mode: 'single',\n        callbacks: {\n            title: function(tooltipItems, data) {\n                return data.labels[tooltipItems[0].datasetIndex];\n            },\n            label: function(tooltipItem, data) {\n                \n                return [\"Started: \" + moment(data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index][0]).fromNow(),\n                    \"Duration: \" + moment(data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index][1]).from(data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index][0], true)\n                    ]\n            }\n        }\n    }\n};\n\n</script>","storeOutMessages":true,"fwdInMessages":true,"resendOnRefresh":false,"templateScope":"global","x":650,"y":380,"wires":[[]]},{"id":"6a9139e6.e34528","type":"csv","z":"2f489a1c.4a05b6","name":"","sep":",","hdrin":"","hdrout":"none","multi":"one","ret":"\\n","temp":"count, label","skip":"0","strings":true,"include_empty_strings":"","include_null_values":"","x":110,"y":340,"wires":[["2fe5041f.9ea24c","17eff56e.0af92b","6828b57b.9f9c7c"]]},{"id":"17eff56e.0af92b","type":"function","z":"2f489a1c.4a05b6","d":true,"name":"","func":"var label = msg.payload.label\nif (label == \"flag1\") {\n    m = 1,\n    s = \"part1\"\n} else if (label == \"flag2\") {\n    m = 2,\n    s = \"part2\"\n}else if (label == \"flag3\") {\n    m = 3,\n    s = \"part3\"\n}else if (label == \"flag4\") {\n    m = 4,\n    s = \"part4\"\n}\nmsg.payload = m\nmsg.topic = s;\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":360,"y":240,"wires":[["f7c24ac4.7bc638","8da01ad2.268c08"]]},{"id":"f7c24ac4.7bc638","type":"debug","z":"2f489a1c.4a05b6","name":"","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":530,"y":220,"wires":[]},{"id":"47716e24.62db6","type":"change","z":"2f489a1c.4a05b6","name":"Part1_true","rules":[{"t":"set","p":"payload","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"topic","pt":"msg","to":"part1","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":380,"wires":[["8da01ad2.268c08"]]},{"id":"6828b57b.9f9c7c","type":"switch","z":"2f489a1c.4a05b6","name":"","property":"payload.label","propertyType":"msg","rules":[{"t":"eq","v":"flag1","vt":"str"},{"t":"eq","v":"flag2","vt":"str"},{"t":"eq","v":"flag3","vt":"str"},{"t":"eq","v":"flag4","vt":"str"}],"checkall":"true","repair":false,"outputs":4,"x":170,"y":460,"wires":[["47716e24.62db6","8484d965.b16868","b622ce6d.03345","62efd555.a82efc"],["4e2627ef.7e3868","7cd6d7fd.81a8e8","b622ce6d.03345","62efd555.a82efc"],["8484d965.b16868","b097e923.9894a8","4e2627ef.7e3868","62efd555.a82efc"],["b622ce6d.03345","4e2627ef.7e3868","8484d965.b16868"]]},{"id":"4e2627ef.7e3868","type":"change","z":"2f489a1c.4a05b6","name":"part1_false","rules":[{"t":"set","p":"payload","pt":"msg","to":"false","tot":"bool"},{"t":"set","p":"topic","pt":"msg","to":"part1","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":480,"wires":[["8da01ad2.268c08"]]},{"id":"7cd6d7fd.81a8e8","type":"change","z":"2f489a1c.4a05b6","name":"part2_true","rules":[{"t":"set","p":"payload","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"topic","pt":"msg","to":"part2","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":400,"wires":[["8da01ad2.268c08"]]},{"id":"8484d965.b16868","type":"change","z":"2f489a1c.4a05b6","name":"part2_false","rules":[{"t":"set","p":"payload","pt":"msg","to":"false","tot":"bool"},{"t":"set","p":"topic","pt":"msg","to":"part2","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":500,"wires":[["8da01ad2.268c08"]]},{"id":"b097e923.9894a8","type":"change","z":"2f489a1c.4a05b6","name":"part3_true","rules":[{"t":"set","p":"payload","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"topic","pt":"msg","to":"part3","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":420,"wires":[["8da01ad2.268c08"]]},{"id":"b622ce6d.03345","type":"change","z":"2f489a1c.4a05b6","name":"part3_false","rules":[{"t":"set","p":"payload","pt":"msg","to":"false","tot":"bool"},{"t":"set","p":"topic","pt":"msg","to":"part3","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":520,"wires":[["8da01ad2.268c08"]]},{"id":"89f82c7d.f43c","type":"change","z":"2f489a1c.4a05b6","name":"part4_true","rules":[{"t":"set","p":"payload","pt":"msg","to":"true","tot":"bool"},{"t":"set","p":"topic","pt":"msg","to":"part4","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":440,"wires":[["8da01ad2.268c08"]]},{"id":"62efd555.a82efc","type":"change","z":"2f489a1c.4a05b6","name":"part4_false","rules":[{"t":"set","p":"payload","pt":"msg","to":"false","tot":"bool"},{"t":"set","p":"topic","pt":"msg","to":"part4","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":370,"y":540,"wires":[["8da01ad2.268c08"]]}]